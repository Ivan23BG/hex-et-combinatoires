\section{Gestion du Projet}

% présenter la gestion du projet et les documents de planification éventuellement
% rédigés (par exemple, le diagramme de Gantt).
Pour la gestion du projet, nous avons suivi un cycle de développement similaire à celui de la méthode Scrum. 
Nous avons donc défini des sprints courts de quelques jours chaque semaine, avec une réunion hebdomadaire
le mercredi pour faire le point sur l'avancement du projet. 
Ces réunions étaient l'occasion de discuter des tâches effectuées, de celles à venir, et de résoudre les problèmes rencontrés.
Nous avons également utilisé le logiciel Jira pour gérer les tâches et les sprints, et pour suivre l'avancement du projet.

\subsection{Diagramme de Gantt}
Officiellement, nous n'avons pas utilisé de diagramme de Gantt pour la gestion du projet, mais nous avons tout de même
réalisé un planning prévisionnel des tâches à effectuer.
Ce planning a été réalisé en début de projet, et a été mis à jour régulièrement pour refléter l'avancement du projet.
Il a été utilisé pour définir les tâches à effectuer pour chaque sprint, et pour suivre l'avancement du projet.
Un exemple de diagramme de Gantt est présenté en annexe \ref{fig:diagramme_de_gantt}.


\subsection{Organisation}
Avec ce fonctionnement, chaque semaine nos avions de nouvelles tâches à accomplir, celles-ci pouvaient être par exemple ajouter une fonctionnalité ou le débogage, l'ajout d'éléments graphiques, etc...
Les plus grosses tâches étant l'ajout de nouveaux jeux, pour celles-ci nous avons procédé comme ceci :
Une première version du jeu est ajoutée avec sa classe Python. Cette première version contient les fonctionnalités de base et est jouable dans le terminal dans le but de faire des tests. 
L'étape suivante est de créer une page web d'accueil et une autre pour le jeu, ainsi que de créer le plateau de jeu en HTML/CSS/JavaScript. La dernière étape est de relier la classe 
Python avec le site web en utilisant Flask.
À ce stade, le jeu est jouable sur le site web. Ce cycle a duré 2 à 3 semaines pour les 2 jeux que nous avons implémentés. Ensuite vient la phase où il faut déboguer et ajouter les 
fonctionnalités comme la possibilité de jouer contre l'IA ou améliorer l'interface graphique. En pratique, l'implémentation du jeu prend beaucoup moins de temps que de l'optimiser, 
le déboguer, et ajouter toutes sortes de petites fonctionnalités.
Nous pouvons noter que grâce à l'architecture du projet, il est facile d'ajouter de nouveaux jeux : il suffit d'écrire une classe similaire à celle d'un autre jeu et d'ajouter une 
page web correspondante. C'est aussi le cas pour certaines fonctionnalités comme le MinMax : il suffit de recopier l'algorithme dans la nouvelle classe (notez que ce n'est pas du tout le cas pour les fonctions d'évaluation qui sont propres à chaque jeu).
Nous avons construit le projet comme une plateforme pour les jeux combinatoires, pour y jouer et pour essayer les différents moteurs de jeux que nous pouvons implémenter.



% discuter les changements majeurs effectués en cours de projet
\subsection{Changements Majeurs}

Les reunions hebdomadaires etaient l'occasion de nous mettre d'accord entre nous et avec notre encadrant sur
les changements majeurs a apporter sur le projet pendant le developpement, en voici une liste non exaustive:

\begin{itemize}
    \item Changement de la hiérarchie des classes: nous avons changé la hiérarchie des classes pour
    une homogénéisation du code et une meilleure compréhension.
    \item Changement de l'organisation des fichiers: nous avons changé l'organisation des fichiers pour
    mieux organiser le code et faciliter la maintenance. Cela a initialement été fait pour le backend, puis
    pour le frontend. Beaucoup de problèmes ont été rencontrés lors de ces changements, mais ils ont permis
    d'améliorer la qualité du code.
    \item Changement de la gestion des erreurs: nous avons changé la gestion des erreurs pour une meilleure
    gestion des exceptions et une meilleure gestion des erreurs. Cela a permis d'améliorer la robustesse du code.
    Cela a également renforcé la sécurité du code sans nuire à la performance ou au debuggage.
\end{itemize}

